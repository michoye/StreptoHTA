---
title: "StreptoHTA Group 4 Assignment"
output: html_document
---

For this work we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention: Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 1329–1339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

Other work from DARTH can be found on the website: <http://darthworkgroup.com/publications/>

# Is Throat Culture More Cost-Effective than Rapid Antigen Diagnostic Testing (RADT) for Diagnosisng Group A Streptococcus (GAS) in Pedriatric Sore Throat Patients?

In this exercise, we will model Group A Streptococcal (GAS) pharyngitis using an individual-based state-transition model, commonly referred to as a microsimulation model. This model will simulate the progression of patients experiencing sore throat symptoms, incorporating two diagnostic strategies: Rapid Antigen Detection Test (RADT) and Throat Culture (TC).

**Table 1: Input parameters for the time dependent Sick-Sicker Microsimulation**

| **Parameter** | **R name** | **Value** |
|:----------------------------|:-------------------|:-------------------:|
| Time horizon | `n_cycles` | 5 years |
| Cycle length | `cycle_length` | 1 month |
| Names of simulated individuals | `n_i` | 100000 |
| Names of health states | `v_names_states` | H, S, D |
| Monthly discount rate (costs/QALYs) | `d_e` `d_c` | 3% |
| Population characteristics |  |  |
| \- Age distribution | -- | Range: 5-55 distributed as in `MyPopulation-AgeDistribution.csv` |
| Monthly transition probabilities conditional on survival |  |  |
| \- Disease onset (H to S) | `p_HS` | Age dependent (0.1 for adults vs. 0.4 for children) |
| \- Recovery (S to H) | `p_SH` | 0.88 vs. 0.93 |
| Monthly mortality |  |  |
| \- All-cause mortality (H to D) | `p_HD` | Human Mortality Database (`mortProb_age.csv`): age dependent from 2015 |
| \- Probability of death if S (S to D) | `p_SD` | dependent on state-residency |
| Monthly costs |  |  |
| \- Healthy individuals | `c_H` | \$500 |
| \- Sick individuals in S | `c_S` | \$750 |
| \- Dead individuals | `c_D` | \$0 |
| \- Additional cost of diagnosis for sick individuals (Throat Culture vs. RADT) | `c_diagAB` | \$40 |
| Utility weights |  |  |
| \- Healthy individuals | `u_H` | 1.00 |
| \- Sick individuals in S | `u_S` | 0.85 |
| \- Dead individuals | `u_D` | 0.00 |
| Intervention effect |  |  |
| \- Utility for treated individuals in S | `u_diagAB` | 0.95 |
| Time varying extension of Sick-Sicker model |  |  |
| \- Treatment effect modifier at baseline | `v_x` | Uniform(0.95, 1.05) |

# 01 Load packages

```{r, warning = F, message = F}
if (!require('pacman')) install.packages('pacman')

library(pacman) # use this package to conveniently install other packages
# load (install if required) packages from CRAN
p_load("dplyr", "tidyr", "reshape2", "devtools", "scales", "ellipse", "ggplot2", "ggrepel", "gridExtra", "lazyeval", "igraph", "truncnorm", "ggraph", "reshape2", "patchwork", "knitr", "stringr", "diagram")                                       
library(dampack)
# load (install if required) packages from GitHub
# install_github("DARTH-git/darthtools", force = TRUE) #Uncomment if there is a newer version

p_load_gh("DARTH-git/darthtools")
```

# 02 Load functions

```{r}
# all needed functions are in the darthtools package
```

# 03 Model input

```{r}
## General setup 
set.seed(1)               # set the seed  
cycle_length   <- 1/12       # cycle length equal to one year (use 1/12 for monthly)
n_cycles       <- 24      # time horizon, number of cycles
n_i            <- 10000  # number of individuals

# the 4 health states of the model:
v_names_states  <- c("H",  # Healthy (H)
                     "S", # Sick (S)
                     "D")  # Dead (D)
v_names_cycles  <- paste("cycle", 0:n_cycles)    # cycle names
n_states        <- length(v_names_states) # number of health states               

### Discounting factors 
d_c <- 0.03 # monthly discount rate for costs 
d_e <- 0.03 # monthly discount rate for QALYs


### Strategies 
v_names_str   <- c("Standard of care",   # This is the RADT
                   "Strategy AB")        # Throat Culture
n_str         <- length(v_names_str)     # number of strategies

### Transition probabilities 
# (all non-probabilities are conditional on survival)

# if (df_X[, dist_Age$age] > 18) {
#  p_HS <- 0.1
# } else {
#  p_HS <- 0.4
# }

p_HS         <- 1 - (1 - 0.1)^(1/12)     # probability of becoming sick when healthy
p_SH_SoC         <- 1 - (1 - 0.88)^(1/12)      # probability of recovering to healthy when sick and diagnosed through SoC
p_SH_diagAB          <- 1 - (1 - 0.93)^(1/12)  # probability of recovering to healthy when sick and diagnosed through AB


# Monthly probabilities of death
# load age dependent probability
p_mort   <- read.csv("data/mortProb_age.csv")
# Adjust to monthly probabilities
p_mort$p_HD <- 1 - (1 - p_mort$p_HD)^(1/12)

# load age distribution
dist_Age <- read.csv("data/MyPopulation-AgeDistribution.csv") 

# Monthly probabilities of becoming sick
# We created a new matrix
df_p_sick <- data.frame(Age = 1:107)
df_p_sick$p_HS <- ifelse(df_p_sick$Age <= 18, 0.4, 0.1)

# probability to die in S by cycle (is increasing)
v_p_SD <- 1 - (1 - c(0.005, 0.007, 0.01, 0.02, 0.03, rep(0.04, n_cycles - 5)))^(1/12)


### State rewards 
#### Costs 
c_H     <- 500 / 12  # monthly cost of being Healthy
c_S     <- 750 / 12  # monthly cost of being Sick
c_D     <- 0     # monthly cost of being dead
c_diagSoC <- 30 # monthly (very inflated) cost (for this assignment) of receiving diagnosis SoC + treatment when in Sick
c_diagAB <- 70 # monthly (very inflated) cost (for this assignment) of receiving diagnosis AB + treatment when in Sick

#### Utilities 
u_H     <- 1     # monthly utility of being Healthy
u_S     <- 0.85  # monthly utility of being Sick
u_D     <- 0     # monthly utility of being dead
u_diagAB <- 0.95  # monthly utility when receiving diagnosis AB when in Sick

  wtp = 20000 # Fictional Willingness-to-pay threshold
```

```{r}
m_P_diag <- matrix(0, nrow = n_states, ncol = n_states, dimnames = list(v_names_states, v_names_states))
m_P_diag["H", "H" ] = ""
m_P_diag["H", "S" ] = ""
m_P_diag["H", "D" ] = ""

m_P_diag["S", "H"] = ""
m_P_diag["S", "S" ] = ""
m_P_diag["S", "D" ] = ""

m_P_diag["D", "D" ] = ""

layout.fig <- c(2, 1)

# Save plot as PNG
png("figs/transition_diagram.png", width = 800, height = 600)
# Generate the plot
plotmat(t(m_P_diag), t(layout.fig), self.cex = 0.5, curve = 0.04, arr.pos = 0.7,
        latex = T, arr.type = "curved", relsize = 0.85, box.prop = 0.8,
        cex = 0.8, box.cex = 0.7, lwd = 1)
# Close the graphical device
dev.off()
```

## Calculate internal model parameters

```{r}
### Discount weight for costs and effects 
v_dwc <- (1 / (1 + d_c)^(1/12)) ^ (0:n_cycles)
v_dwe <- (1 / (1 + d_e)^(1/12)) ^ (0:n_cycles)

# Within-cycle correction (WCC) - method  options Simpson's 1/3 rule, "half-cycle" or "none" 
v_wcc    <- darthtools::gen_wcc(n_cycles = n_cycles, 
                                method = "Simpson1/3") # vector of wcc
```

# 04 Sample individual level characteristics

## 04.1 Static characteristics

```{r}
# sample the treatment effect modifier at baseline
v_x     <- runif(n_i, min = 0.95, max = 1.05) 
# sample from the age distribution the initial age for every individual
v_age0  <- sample(x = dist_Age$age, prob = dist_Age$prop, size = n_i, replace = TRUE) 
```

## 04.2 Dynamic characteristics

Here, we specify the information regarding the initial health states of the individuals as well as in which health state each of the individuals start.

```{r}
v_M_init  <- rep("H", times = n_i)   # Specify the initial health state of the individuals 
v_n_cycles_s_init <- rep(0, n_i)  # everyone begins in the healthy state (in this example)
```

## 04.3 Create a dataframe with the individual characteristics

Now, we merge the static and dynamic individual characteristics into one dataframe.

We created 100000 patients between the age of 5-55 years of age who al start off healthy, with no history of being sick.

```{r}
# data frame with each individual's 
# ID number, treatment effect modifier, age and initial time in sick state and initial health state at the start of the simulation
df_X  <- data.frame(ID = 1:n_i, M_x = v_x, Age = v_age0, n_cycles = v_n_cycles_s_init, M_init = v_M_init)

head(df_X)  # print the first rows of the dataframe

# See also:
# Define the plot
p <- ggplot(df_X, aes(x = Age)) +
    geom_histogram()
# Save the plot as PNG
ggsave("figs/histogram_age.png", plot = p, width = 8, height = 6, dpi = 300)
```

# 05 Define Simulation Functions

## 05.1 Probability function

The `Probs` function updates the transition probabilities of every cycle. Important: (1) The probability from Healthy (H) to Sick (S) (`p_HS`) depends on the age. (2) The probability to die when you are healthy also depends on age (3) The probability from Sick to dead (`p_S1D`) depends on the number of cycles you have been in sick (`n_cycles_s`)

```{r}
Probs <- function(M_t, df_X, Diag = "SoC") { 
  # Arguments:
    # M_t:  health state occupied at cycle t (character variable)
    # df_X: data frame with individual characteristics data 
    # Diag:  diagnosis
  # Returns: 
    # transition probabilities for that cycle

# Diagnosis specific transition probabilities
  if (Diag == "SoC") {
    p_SH <- p_SH_SoC
  } else if (Diag == "AB") {
    p_SH <- p_SH_diagAB 
  }
   
  # create matrix of state transition probabilities
  m_p_t           <- matrix(data = 0, nrow = n_states, ncol = n_i)  
  # give the state names to the rows
  rownames(m_p_t) <-  v_names_states                               
  
  # lookup baseline probability and rate of dying based on individual characteristics
  p_HD_all <- inner_join(x = df_X, y = p_mort, by = c("Age"))
  p_HD     <- p_HD_all[M_t == "H", "p_HD"]
  
  # lookup baseline probability and rate of becoming sick based on individual characteristics (Age)  
  p_HS_all <- inner_join(x = df_X, y = df_p_sick, by = c("Age"))
  p_HS     <- p_HS_all[M_t == "H", "p_HS"]
 
  # update m_p_t with the appropriate probabilities 
  # (all non-death probabilities are conditional on survival)
  # transition probabilities when Healthy 
  m_p_t["H", M_t == "H"] <- (1 - p_HD) * (1 - p_HS)
  m_p_t["S", M_t == "H"] <- (1 - p_HD) * p_HS 
  m_p_t["D", M_t == "H"] <-      p_HD 
  
  
  # transition probabilities when Sick 
  m_p_t["H", M_t == "S"] <-  (1 - v_p_SD[df_X$n_cycles]) * p_SH
  m_p_t["S", M_t == "S"] <-  (1 - v_p_SD[df_X$n_cycles]) * (1 - p_SH)
  m_p_t["D", M_t == "S"] <-      v_p_SD[df_X$n_cycles]   
  

  # transition probabilities when Dead
  m_p_t["H", M_t == "D"] <- 0
  m_p_t["S", M_t == "D"] <- 0
  m_p_t["D", M_t == "D"] <- 1  
  
  return(t(m_p_t))
}       
```

## 05.2 Cost function

The `Costs` function estimates the costs at every cycle.

```{r}
Costs <- function (M_t, Diag = "SoC") {
  # Arguments:
    # M_t: health state occupied at cycle t (character variable)
    # Diag:  diagnosis
  # Returns: 
    # costs accrued in this cycle

    # Diagnosis specific costs
  if (Diag == "SoC") {
    c_diag <- c_diagSoC
  } else if (Diag == "AB") {
    c_diag <- c_diagAB
  } 
  
  c_t <- c()
  c_t[M_t == "H"] <- c_H  # costs accrued by being healthy this cycle
  c_t[M_t == "S"] <- c_S + c_diag         # costs accrued by being sick this cycle
  c_t[M_t == "D"] <- c_D          # costs at dead state
  
  return(c_t)  # return costs accrued this cycle
}

```

## 05.3 Health outcome function

The `Effs` function to update the utilities at every cycle.

```{r}
Effs <- function (M_t, cycle_length = 1, Diag = "SoC") {
  # Arguments:
    # M_t: health state occupied at cycle t (character variable)
    # cl:  cycle length (default is 1)
    # df_X: data frame with individual characteristics data (TA added)
    # Diag:  Diagnosis
  # Returns: 
    # QALYs accrued this cycle 

  u_t <- 0                          # by default the utility for everyone is zero
  u_t[M_t == "H"]    <- u_H         # update the utility if healthy
  
  if (Diag == "SoC") {  # update the utility if sick under standard of care
    u_t[M_t == "S"] <- u_S  
  } else if (Diag == "AB") {
    u_t[M_t == "S"] <- u_diagAB * df_X$x[M_t == "S"]  
  }
  
  u_t[M_t == "D"]    <- u_D         # update the utility if dead
  
  QALYs <- u_t * cycle_length  # calculate the QALYs during cycle t
  return(QALYs)      # return the QALYs accrued this cycle
}
```

## 05.4 The Microsimulation function

```{r}
MicroSim <- function(n_i, df_X, Diag = "SoC", seed = 1, cycle_length = 1, verbose ) {
  # Arguments:  
    # n_i: number of individuals
    # df_X: data frame with individual data 
    # Diag: diagnosis
    # seed: seed for the random number generator, default is 1
    # cycle_length: cycle length 
  # Returns:
    # results: data frame with total cost and QALYs
  
  set.seed(seed) # set a seed to be able to reproduce the same results
  
  # Here, we create three matrices called m_M, m_C and m_E
  # number of rows is equal to the n_i, the number of columns is equal to n_cycles 
  # (the initial state and all the n_cycles cycles)
  # m_M is used to store the health state information over time for every individual
  # m_C is used to store the costs information over time for every individual
  # m_E is used to store the effects information over time for every individual
  
  m_M <- m_C <- m_E <-  matrix(nrow = n_i, ncol = n_cycles + 1, 
                               dimnames = list(paste("ind"  , 1:n_i, sep = " "), 
                                               paste("cycle", 0:n_cycles, sep = " ")))  
 
  m_M[, 1] <- as.character(df_X$M_init) # initial health state at cycle 0 for individual i
  m_C[, 1] <- Costs(m_M[, 1])           # costs per individual during cycle 0
  m_E[, 1] <- Effs( m_M[, 1], cycle_length = cycle_length)   # QALYs per individual during cycle 0
  
  # open a loop for time running cycles 1 to n_cycles 
  for (t in 1:n_cycles) {
    print(t)
    # calculate the transition probabilities for the cycle based on health state t
    m_P <- Probs(m_M[, t], df_X, Diag = Diag)
    # check if transition probabilities are between 0 and 1
    check_transition_probability(m_P, verbose = TRUE)
    # check if each of the rows of the transition probabilities matrix sum to one
    check_sum_of_transition_array(m_P, n_rows = n_i, n_cycles = n_cycles, verbose = TRUE)
    
    # sample the next health state and store that state in matrix m_M
    m_M[, t + 1]  <- samplev(m_P, 1)    
    # calculate costs per individual during cycle t + 1
    m_C[, t + 1]  <- Costs(m_M[, t + 1], Diag = Diag)  
    # calculate QALYs per individual during cycle t + 1
    m_E[, t + 1]  <- Effs (m_M[, t + 1], cycle_length = cycle_length)  
    
    # update time since illness onset for t + 1 
    # NOTE: this code has a "reset of history" for time being sick
    # once someone is not "Sick" anymore, we reset n_cycles (set back to zero)
    # when you don't want a "reset" replace the last zero with the current value
    df_X$n_cycles <- if_else(m_M[, t + 1] == "S", df_X$n_cycles + 1, 0) 
    # update the age of individuals that are alive
    df_X$Age[m_M[, t + 1] != "D"]  <- df_X$Age[m_M[, t + 1] != "D"] + 1
    
    # Display simulation progress
    if(t/(n_cycles/10) == round(t/(n_cycles/10), 0)) { # display progress every 10%
      cat('\r', paste(t/n_cycles * 100, "% done", sep = " "))
    }
    
  } # close the loop for the time points 
  
  # Discounted total expected QALYs and Costs per strategy and apply cycle correction
  tc      <- m_C %*% (v_dwc * v_wcc)  # total (discounted and cycle corrected) cost per individual
  te      <- m_E %*% (v_dwe * v_wcc)  # total (discounted and cycle corrected) QALYs per individual 
  
  tc_hat  <- mean(tc)       # average (discounted and cycle corrected) cost 
  te_hat  <- mean(te)       # average (discounted and cycle corrected) QALY  
  # store the results from the simulation in a list
  results <- list(m_M = m_M, m_C = m_C, m_E = m_E, tc = tc , te = te, 
                  tc_hat = tc_hat, te_hat = te_hat)   
  
  return(results)  # return the results

}
```

# 06 Run Microsimulation

```{r, eval = TRUE, echo = TRUE, warning = FALSE, message = FALSE, results = FALSE }
outcomes_SoC  <- MicroSim(n_i = n_i, df_X = df_X, seed = 1, cycle_length = cycle_length, Diag = "SoC")  # Run for Standard of Care
outcomes_diagAB <- MicroSim(n_i = n_i, df_X = df_X, seed = 1, cycle_length = cycle_length, Diag = "AB") # Run simulation for strategy AB
```

# 07 Visualize results

```{r}
# Standard of Care
# Save the first plot (Total Cost per Person)
png("figs/SoC_total_cost_per_person.png", width = 800, height = 600)
plot(density(outcomes_SoC$tc), main = "Total cost per person", xlab = "Cost ($)")
dev.off()
# Save the second plot (Total QALYs per Person)
png("figs/SoC_total_qalys_per_person.png", width = 800, height = 600)
plot(density(outcomes_SoC$te), main = "Total QALYs per person", xlab = "QALYs")
dev.off()
# Save the third plot (Health State Trace)
png("figs/SoC_health_state_trace.png", width = 800, height = 600)
plot_trace_microsim(outcomes_SoC$m_M)
dev.off()

# Show all plots in R (without saving)
par(mfrow = c(1, 3))  # Arrange plots in 1 row, 3 columns
plot(density(outcomes_SoC$tc), main = "Total cost per person", xlab = "Cost ($)")
plot(density(outcomes_SoC$te), main = "Total QALYs per person", xlab = "QALYs")
plot_trace_microsim(outcomes_SoC$m_M)
par(mfrow = c(1, 1))  # Reset layout
```

The first plot represents the distribution of total costs per person. The cost distribution is right-skewed, indicating that while most individuals accumulate costs in the \$3000-4000 range, some cases incur significantly higher costs.

The second plot illustrates the distribution of total quality-adjusted life years (QALYs) per individual. There is a strong peak around 4 QALYs, suggesting that most individuals maintain a relatively high quality of life and long survival.

The third graph tracks the proportion of individuals in each health state over 60 cycles (= 5 years). Initially, all individuals start in the Healthy (H) state, but over time, more transition into the Sick (S) state. The Sick state increases rapidly in the first few cycles before stabilizing and declining. Meanwhile, the proportion of deceased individuals (D) gradually but slowly rises, reflecting the low mortality rate for the disease. The total proportion correctly sums to 1 at each cycle.

```{r}
# Strategy AB
# Save the first plot (Total Cost per Person)
png("figs/AB_total_cost_per_person_AB.png", width = 800, height = 600)
plot(density(outcomes_diagAB$tc), main = "Total cost per person (Treatment AB)", xlab = "Cost ($)")
dev.off()
# Save the second plot (Total QALYs per Person)
png("figs/AB_total_qalys_per_person_AB.png", width = 800, height = 600)
plot(density(outcomes_diagAB$te), main = "Total QALYs per person (Treatment AB)", xlab = "QALYs")
dev.off()
# Save the third plot (Health State Trace)
png("figs/AB_health_state_trace_AB.png", width = 800, height = 600)
plot_trace_microsim(outcomes_diagAB$m_M)
dev.off()

# Show all plots in R (without saving)
par(mfrow = c(1, 3))  # Arrange plots in 1 row, 3 columns
plot(density(outcomes_diagAB$tc), main = "Total cost per person (Treatment AB)", xlab = "Cost ($)")
plot(density(outcomes_diagAB$te), main = "Total QALYs per person (Treatment AB)", xlab = "QALYs")
plot_trace_microsim(outcomes_diagAB$m_M)
par(mfrow = c(1, 1))  # Reset layout

```

The first plot represents the distribution of total costs per person. The distribution is right-skewed, with most costs accumulating in the range of \$4000-5000. Some individuals incur higher costs (\~\$6000 or more) due to extended illness duration, complications, or more intensive treatment.

The second plot illustrates the distribution of total quality-adjusted life years (QALYs) per individual. Most individuals accumulate around 4 QALYs, suggesting that they experience good quality of life and survive most of the simulation period. The right-skewed shape indicates that some individuals accumulate fewer QALYs due to prolonged sickness or early death.

The third plot tracks the proportion of individuals in each health state over time. Initially, a large fraction transitions into the sick (S) state, peaking around cycle 10. Over time, many recover (S → H), but a subset remains chronically sick. The proportion of deceased individuals (D) gradually rises, reflecting normal mortality progression, while the healthy (H) population stabilizes.

# 08 Cost-effectiveness analysis (CEA)

```{r}
# store the mean costs of each strategy in a new variable C (vector of costs)
v_C <- c(outcomes_SoC$tc_hat, outcomes_diagAB$tc_hat)
# store the mean QALYs of each strategy in a new variable E (vector of effects)
v_E <- c(outcomes_SoC$te_hat, outcomes_diagAB$te_hat)

# use dampack to calculate the ICER
df_cea <- calculate_icers(cost       = v_C,
                          effect     = v_E,
                          strategies = v_names_str)
df_cea

## CEA table in proper format 
table_cea <- format_table_cea(df_cea) 

# Save the table as a CSV file
write.csv(table_cea, "tables/CEA_table.csv", row.names = FALSE)
# For use in R:
saveRDS(table_cea, "tables/CEA_table.rds")
# table_cea <- readRDS("tables/CEA_table.rds")
table_cea

```

Strategy AB costs \$697 more per person than Standard of Care but provides only a small QALY gain (0.05 QALYs).

The ICER of \$14,247 per QALY suggests that Strategy AB is cost-effective if the willingness-to-pay threshold is higher than this value. If the WTP is below \$14,247, Standard of Care remains the preferred option.

```{r}
## CEA frontier 
# Save as PNG
png("figs/cea_plot.png", width = 800, height = 600)
# Generate the plot
plot(df_cea, label = "all", txtsize = 14) +
  theme(legend.position = c(0.8, 0.3))
# Close the graphical device
dev.off()

# Show the plot
plot(df_cea, label = "all", txtsize = 14) +
  theme(legend.position = c(0.8, 0.3))
```

The efficient frontier confirms that Strategy AB is more effective but at a higher cost. The incremental cost-effectiveness ratio (ICER) is \~\$14,247/QALY, meaning Strategy AB is cost-effective only if decision-makers are willing to pay at least this amount per QALY gained. The choice depends on the WTP threshold—if higher than \$14,247/QALY, Strategy AB is preferred, otherwise, SoC remains the cost-effective choice.

# 09 Deterministic Sensitivity Analysis

```{r}

## Load model, CEA and PSA
source('Functions_StreptoHTA.R')
```

## 09.1 Model input for SA

```{r}
l_params_all <- list(
  # Transition probabilities
  # probability of dying
  p_HS         = 1 - (1 - 0.1)^(1/12),     # probability of becoming sick when healthy
  p_SH_SoC         = 1 - (1 - 0.88)^(1/12),      # probability of recovering to healthy when sick and diagnosed through SoC
  p_SH_diagAB          = 1 - (1 - 0.93)^(1/12),  # probability of recovering to healthy when sick and diagnosed through AB

  
  # Costs 
  c_H     = 500 / 12,  # monthly cost of being Healthy
  c_S     = 750 / 12,  # monthly cost of being Sick
  c_D     = 0,     # monthly cost of being dead
  c_diagSoC = 30, # monthly (very inflated) cost (for this assignment) of receiving diagnosis SoC + treatment when in Sick
  c_diagAB = 70, # monthly (very inflated) cost (for this assignment) of receiving diagnosis AB + treatment when in Sick


  # Utilities 
  u_H     = 1,     # monthly utility of being Healthy
  u_S     = 0.85,  # monthly utility of being Sick
  u_D     = 0,     # monthly utility of being dead
  u_diagAB = 0.95,  # monthly utility when receiving diagnosis AB when in Sick

  # Discount rates
  d_e       = 0.03,  # discount rate per cycle equal discount of costs and QALYs by 3%
  d_c       = 0.03,  # discount rate per cycle equal discount of costs and QALYs by 3%
  # Time horizon
  n_cycles  = 24,     # simulation time horizon (number of cycles)
  cycle_length   = 1/12,
  
  wtp = 20000
  
  
)
```

**Test model functions**

Two functions were defined in the 'Functions_StreptoHTA`.R'` file. The first was the `decision_model()` function which takes in model parameters and outputs the Microsiulation results. The second is the `calculate_ce_out()` function which calls `decision_model()` and uses the resulting Microsimulation results to compute the total costs, QALYs, returning a data frame of costs and QALYs.

```{r}
# Try the calculate_ce_out() function
df_ce <- calculate_ce_out(l_params_all)
df_ce

# Get strategies names (will be used to label plots)
v_names_str <- df_ce$Strategy
n_str <- length(v_names_str)
```

## 9.2 One-way sensitivity analysis (OWSA)

### 9.2.1 OWSA cost parameters only

```{r}
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and 
# max values of the parameters of interest 
df_params_owsa <- data.frame(pars = c("c_diagAB", "c_S"),
                             min  = c(20, 30),  # min parameter values
                             max  = c(100, 150)  # max parameter values
                             )
owsa_nmb  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
                          params_basecase  = l_params_all,      # list with all parameters
                          nsamp            = 100,               # number of parameter values
                          FUN              = calculate_ce_out,  # function to compute outputs
                          outcomes         = c("NMB"),          # output to do the OWSA on
                          strategies       = v_names_str,       # names of the strategies
                          n_wtp            = 20000)              # extra argument to pass to FUN
```

```{r}
plot(owsa_nmb, txtsize = 10, n_x_ticks = 4, 
     facet_scales = "free") +
     theme(legend.position = "bottom")
```

### 10.2.2 OWSA demonstrating other values

A OWSA does not have to be not limited to costs. All types of input parameters can be explored, like utility value

```{r}
options(scipen = 999) # disabling scientific notation in R
# dataframe containing all parameters, their base case values, and the min and 
# max values of the parameters of interest 
df_params_owsa <- data.frame(pars = c("p_HS", "u_S"),
                             min  = c(0.005,   0.70),  # min parameter values
                             max  = c(0.05, 0.95)  # max parameter values
                             )

# Make a new object, for the rates and utilities we like to explore
# We call it owsa_nmb_r_u
owsa_nmb_r_u  <- run_owsa_det(params_range     = df_params_owsa,    # dataframe with parameters for OWSA
                              params_basecase  = l_params_all,      # list with all parameters
                              nsamp            = 100,               # number of parameter values
                              FUN              = calculate_ce_out,  # function to compute outputs
                              outcomes         = c("NMB"),          # output to do the OWSA on
                              strategies       = v_names_str,       # names of the strategies
                              n_wtp            = 20000)              # extra argument to pass to FUN
```

```{r}
plot(owsa_nmb_r_u, txtsize = 10, n_x_ticks = 4, 
     facet_scales = "free") +
     theme(legend.position = "bottom")
```

## 9.3 Two-way sensitivity analysis (TWSA)

```{r}
# dataframe containing all parameters, their basecase values, and the min and 
# max values of the parameters of interest
df_params_twsa <- data.frame(pars = c("c_diagSoC", "c_diagAB"),
                             min  = c(10, 50),  # min parameter values
                             max  = c(50, 100) # max parameter values
                             )

twsa_nmb <- run_twsa_det(params_range    = df_params_twsa,    # dataframe with parameters for TWSA
                         params_basecase = l_params_all,      # list with all parameters
                         nsamp           = 40,                # number of parameter values
                         FUN             = calculate_ce_out,  # function to compute outputs
                         outcomes        = "NMB",             # output to do the TWSA on
                         strategies      = v_names_str,       # names of the strategies
                         n_wtp           = 20000)              # extra argument to pass to FUN
```

### 9.3.1 Plot TWSA

```{r}
plot(twsa_nmb)
```

# 10 Probabilistic Sensitivity Analysis (PSA)

## 10.1 Model input

```{r}
# Store the parameter names into a vector
v_names_params <- names(l_params_all)

## Test functions to generate CE outcomes and PSA dataset 
# Test function to compute CE outcomes
calculate_ce_out(l_params_all) 

# Test function to generate PSA input dataset
generate_psa_params(n_sim = 10) 

## Generate PSA dataset 
# Number of simulations
n_sim <- 100

# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)
# First six observations
head(df_psa_input)

### Histogram of parameters 
ggplot(melt(df_psa_input, variable.name = "Parameter"), aes(x = value)) +
  facet_wrap(~Parameter, scales = "free") +
  geom_histogram(aes(y = ..density..)) +
  ylab("") +
  theme_bw(base_size = 16) + 
  theme(axis.text = element_text(size = 6),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y  = element_blank(),
        axis.ticks.y = element_blank()) 
```

## 10.2 Run PSA

```{r}
# Initialize data.frames with PSA output 
# data.frame of costs
df_c <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_c) <- v_names_str
# data.frame of effectiveness
df_e <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_e) <- v_names_str

# Conduct probabilistic sensitivity analysis
# Run Markov model on each parameter set of PSA input dataset
n_time_init_psa_series <- Sys.time()
for (i in 1:n_sim) { # i <- 1
  l_psa_input <- update_param_list(l_params_all, df_psa_input[i,])
  # Outcomes
  l_out_ce_temp  <- calculate_ce_out(l_psa_input)
  df_c[i, ]  <- l_out_ce_temp$Cost  
  df_e[i, ]  <- l_out_ce_temp$Effect
  # Display simulation progress
  if (i/(n_sim/100) == round(i/(n_sim/100), 0)) { # display progress every 5%
    cat('\r', paste(i/n_sim * 100, "% done", sep = " "))
  }
}
n_time_end_psa_series <- Sys.time()
n_time_total_psa_series <- n_time_end_psa_series - n_time_init_psa_series
print(paste0("PSA with ", scales::comma(n_sim), " simulations run in series in ", 
             round(n_time_total_psa_series, 2), " ", 
             units(n_time_total_psa_series)))
```

# 10.3 Visualize PSA results for CEA

```{r}
### Create PSA object 
l_psa <- make_psa_obj(cost          = df_c, 
                      effectiveness = df_e, 
                      parameters    = df_psa_input, 
                      strategies    = v_names_str)
l_psa$strategies <- v_names_str
colnames(l_psa$effectiveness) <- v_names_str
colnames(l_psa$cost) <- v_names_str

# Vector with willingness-to-pay (WTP) thresholds.
v_wtp <- seq(0, 20000, by = 1000)
```

## 10.3.1 Cost-Effectiveness Scatter plot

```{r}
### Cost-Effectiveness Scatter plot 
txtsize <- 13
gg_scattter <- plot_psa(l_psa, txtsize = txtsize) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  scale_y_continuous("Cost (Thousand $)", 
                     breaks = number_ticks(10),
                     labels = function(x) x/1000) +
  xlab("Effectiveness (QALYs)") +
  guides(col = guide_legend(nrow = 2)) +
  theme(legend.position = "bottom")
gg_scattter
```

## 10.3.2 Incremental cost-effectiveness ratios (ICERs) with probabilistic output

```{r}
### Incremental cost-effectiveness ratios (ICERs) with probabilistic output 
# Compute expected costs and effects for each strategy from the PSA
df_out_ce_psa <- summary(l_psa)
df_cea_psa <- calculate_icers(cost       = df_out_ce_psa$meanCost, 
                              effect     = df_out_ce_psa$meanEffect,
                              strategies = df_out_ce_psa$Strategy)
df_cea_psa
```

## 10.3.3 Plot cost-effectiveness frontier with probabilistic output

```{r}
### Plot cost-effectiveness frontier with probabilistic output 
plot_icers(df_cea_psa, label = "all", txtsize = txtsize) +
  expand_limits(x = max(table_cea$QALYs) + 0.1) +
  theme(legend.position = c(0.8, 0.3))
```

## 10.3.4 Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF)

This figure shows the Cost-effectiveness acceptability curves. The CEAC shows the probability that a specific strategy is cost-effective (based on all results from the PSA iterations). The cost-effectiveness frontier consist of the set of points corresponding to treatment alternatives taht are considered cost-effective at differnet values of the WTP threshold.

```{r}
### Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF) 
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
# Regions of highest probability of cost-effectiveness for each strategy
summary(ceac_obj)
# CEAC & CEAF plot
gg_ceac <- plot_ceac(ceac_obj, txtsize = txtsize, xlim = c(0, NA), n_x_ticks = 14) +
  ggthemes::scale_color_colorblind() +
  ggthemes::scale_fill_colorblind() +
  theme(legend.position = c(0.8, 0.48))
gg_ceac
```

# Acknowlegdement

For this work we made use of the template developed by the Decision Analysis in R for Technologies in Health (DARTH) workgroup: <http://darthworkgroup.com>.

The notation of our code is based on the following provided framework and coding convention: Alarid-Escudero, F., Krijkamp, E., Pechlivanoglou, P. et al. A Need for Change! A Coding Framework for Improving Transparency in Decision Modeling. PharmacoEconomics 37, 1329–1339 (2019). <https://doi.org/10.1007/s40273-019-00837-x>.

-   Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P, Jalal H. An Introductory Tutorial on Cohort State-Transition Models in R Using a Cost-Effectiveness Analysis Example. Medical Decision Making, 2023; 43(1). (Epub). <https://doi.org/10.1177/0272989X221103163>

-   Alarid-Escudero F, Krijkamp EM, Enns EA, Yang A, Hunink MGM Pechlivanoglou P, Jalal H. A Tutorial on Time-Dependent Cohort State-Transition Models in R using a Cost-Effectiveness Analysis Example. Medical Decision Making, 2023; 43(1). <https://doi.org/10.1177/0272989X221121747>

Other work from DARTH can be found on the website: <http://darthworkgroup.com/publications/>

# Copyright for assignment work

Copyright 2017, THE HOSPITAL FOR SICK CHILDREN AND THE COLLABORATING INSTITUTIONS.All rights reserved in Canada, the United States and worldwide. Copyright, trademarks, trade names and any and all associated intellectual property are exclusively owned by THE HOSPITAL FOR Sick CHILDREN and the collaborating institutions. These materials may be used, reproduced, modified, distributed and adapted with proper attribution.
